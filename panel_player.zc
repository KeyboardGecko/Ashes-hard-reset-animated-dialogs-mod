class PanelPlayer : Object
{
    bool ready;
    Array<TextureID> frames;

    Array<String> animNames;
    Array<int>    clipOffset, clipCount;
    Array<bool>   clipLoop, clipStopLast;
    Array<int>    flatFrames;
    Array<int>    flatDurMs;

    int  curClip, seqPos;
    bool active;
    int  lastFrameIdx;

    // рендерная геометрия — как у тебя
    int vW, vH;
    double topMargin;

    double timeLeftMs;  

	String snd;

	TextureID tex;
	Vector2 sz;
	double x;
	double y;

	String character;
	Array<String> loadedChars; 

    static int IndexOfStr(Array<String> arr, String s)
    {
        for (int i=0;i<arr.Size();i++) if (arr[i] == s) return i;
        return -1;
    }

	int EnsureFrameIndexByName(String name) { 
		for (int i = 0; i < frames.Size(); i++) { 	
		if (TexMan.GetName(frames[i]) == name) return i; } 
		TextureID id = TexMan.CheckForTexture(name); 
		if (!id.IsValid()) return -1; 
		frames.Push(id); 
		return frames.Size() - 1; 
	}
	
	
    ui void EnsureCharacterForVoice(String voiceName)
    {
		String clearVoiceName = (voiceName.RightIndexOf("/") >= 0) ? voiceName.Mid(voiceName.RightIndexOf("/") + 1) : voiceName;
        String who = AnimRegistryLang.ResolveCharFromVoice(clearVoiceName);

        if (who.Length()==0) return;

        // Регистрируем анимации этого персонажа один раз
        if (IndexOfStr(loadedChars, who) < 0)
        {
            AnimRegistryLang.PreloadFor(self, who);
            AnimRegistryLang.RegisterFor(self, who, true);
            loadedChars.Push(who);
        }
        character = who; // активный персонаж
    }


    bool HasAnim(String n) { return FindAnim(n) >= 0; }

    ui void PreloadOnce()
    {
        if (ready) return;

        curClip = -1; seqPos = 0; timeLeftMs = 0.0;
        active = false; lastFrameIdx = 0;
        vW = 320; vH = 200; topMargin = 0.0;
        ready = true;
    }

    // --- вспомогательные маппинги ---
	

  // --- регистрация клипов без конвертации в тики ---
    void DefineAnimation(String name, Array<int> fIdx, Array<int> durMs, bool loop=false, bool stopLast=true)
    {
        int n = min(fIdx.Size(), durMs.Size());
        if (n <= 0) return;

        int off = flatFrames.Size();
        for (int i = 0; i < n; i++)
        {
            int fi = fIdx[i]; if (fi < 0 || fi >= frames.Size()) continue;
            flatFrames.Push(fi);
            int ms = durMs[i]; if (ms <= 0) ms = 1;
            flatDurMs.Push(ms);                 // ← сохраняем миллисекунды
        }
        int cnt = flatFrames.Size() - off;
        if (cnt <= 0) return;

        int idx = FindAnim(name);
        if (idx >= 0) {
            clipOffset[idx] = off; clipCount[idx] = cnt;
            clipLoop[idx] = loop;  clipStopLast[idx] = stopLast;
        } else {
            animNames.Push(name);
            clipOffset.Push(off); clipCount.Push(cnt);
            clipLoop.Push(loop);  clipStopLast.Push(stopLast);

        }
    }

    void DefineAnimationByNames(String name, Array<String> fNames, Array<int> durMs, bool loop=false, bool stopLast=true)
    {
		Console.printf("here goes name, %s ", name);

        Array<int> idx;
        int n = min(fNames.Size(), durMs.Size());
        for (int i = 0; i < n; i++)
        {
            int fi = EnsureFrameIndexByName(fNames[i]);
            if (fi >= 0) idx.Push(fi);
        }
        if (idx.Size() == 0) {
			Console.printf("animation doesn't work - idx.size = 0:, %s ", name);
		return;
		}

        DefineAnimation(name, idx, durMs, loop, stopLast);
    }

	static String GetAnimationName(String path, String separator = "/")
	{
		int pos = path.RightIndexOf(separator);
		return (pos >= 0) ? path.Mid(pos + 1) : path;
	}


    ui bool PlayAnim(String name)
    {
        PreloadOnce();
        int idx = FindAnim(GetAnimationName(name));
	
		if (idx < 0) { Console.Printf("Anim not found: %s", name); return false; }
		if (clipCount[idx] <= 0) { Console.Printf("Anim empty: %s", name); return false; }

        if (idx < 0 || clipCount[idx] <= 0) return false;

        curClip = idx; active = true; seqPos = 0;

        int base = clipOffset[idx];
        timeLeftMs = flatDurMs[base];          // ← миллисекунды
        if (timeLeftMs <= 0) timeLeftMs = 1;

        lastFrameIdx = flatFrames[base];
        return true;
    }

	ui bool PlayAnimChar(String name)
    {
		String realName = GetAnimationName(name);
		String full;
        PreloadOnce(); 
		
        if (character.Length()>0)
        {
            full = character .. "." .. realName;
			Console.printf(full);
            if (FindAnim(full) >= 0) return PlayAnim(full);
        }
        return PlayAnim(realName);
    }

	ui bool PlayForVoice(String voiceName)
	{
		EnsureCharacterForVoice(voiceName);      // выставит character = "JM"
		String clip = getAnimationName(voiceName); // "jm/jm001" -> "jm001"
		clip = clip.MakeUpper();                   // "JM001" (как в LIST)
		return PlayAnimChar(clip);                 // соберёт "JM.JM001"
	}

	
	ui void Tick()
    {
        if (!active || curClip < 0) return;
        int cnt = clipCount[curClip];
        if (cnt <= 0) { active = false; return; }

        double dt = 1000.0 / TICRATE;
        timeLeftMs -= dt;

        // Может «перепрыгнуть» через короткие кадры — догоняем while'ом
        while (timeLeftMs <= 0.0)
        {
            seqPos++;
            if (seqPos >= cnt)
            {
                if (clipLoop[curClip])
                {
                    seqPos = 0;
                }
                else
                {
                    active = false;
                    if (clipStopLast[curClip])
                    {
                        int last = clipOffset[curClip] + (cnt - 1);
                        lastFrameIdx = flatFrames[last];
                    }
                    else lastFrameIdx = -1;
                    return;
                }
            }

            int base = clipOffset[curClip] + seqPos;
            // переносим «долг» в следующий кадр
            timeLeftMs += flatDurMs[base];
            lastFrameIdx = flatFrames[base];
        }
    }

    ui void Draw()
    {
        int drawIdx = lastFrameIdx;
        if (active && curClip >= 0)
        {
            int cnt = clipCount[curClip];
            if (cnt > 0 && seqPos >= 0 && seqPos < cnt)
            {
                int base = clipOffset[curClip] + seqPos;
                drawIdx = flatFrames[base];
            }
        }
        if (drawIdx < 0 || drawIdx >= frames.Size()) return;

        TextureID tex = frames[drawIdx]; if (!tex.IsValid()) return;
        Vector2 sz = TexMan.GetScaledSize(tex);
        double x = (vW - sz.x) * 0.5;
        double y = topMargin;

        Screen.DrawTexture(tex, false, x, y,
            DTA_VirtualWidth, vW,
            DTA_VirtualHeight, vH,
            DTA_KeepRatio, true
        );
    }

    int FindAnim(String n)
    {
        for (int i = 0; i < animNames.Size(); i++) if (animNames[i] == n) return i;
        return -1;
    }

		bool IsStopped()
	{
		return !active || curClip < 0 || clipCount[curClip] <= 0;
	}

	bool IsPlaying(String name)
	{
		int idx = FindAnim(name);
		return active && idx == curClip;
	}

	int CurrentFrameIndex()
	{
		if (active && curClip >= 0)
		{
			int count = clipCount[curClip];
			if (count > 0 && seqPos >= 0 && seqPos < count)
			{
				int base = clipOffset[curClip] + seqPos;
				return flatFrames[base];
			}
		}
		return lastFrameIdx;
	}

	String CurrentAnimationName()
	{
		return (curClip >= 0 && curClip < animNames.Size()) ? animNames[curClip] : "";
	}
	


}
