class PanelPlayer : Object
{
    bool ready;
    Array<TextureID> frames;

    Array<String> animNames;
    Array<int>    clipOffset, clipCount;
    Array<bool>   clipLoop, clipStopLast;
    Array<int>    flatFrames;
    Array<double>    flatDurMs;

    int  curClip, seqPos;
    bool active;
    int  lastFrameIdx;

    // рендерная геометрия — как у тебя
    int vW, vH;
    double topMargin;

    double timeLeftMs;  

	String snd;

	String character;
	String prevCharacter;
	
	Array<String> loadedChars; 

    String fallbackTex;  

    ui bool HasAnimInStringTable(String who, String anim)
    {
        String key, s;
        key = "ANIMS_"..who.."_"..anim.."_FRAMES";
        s = Stringtable.Localize(key);
        return s != key;
    }

    ui bool HasValidTexture(String tex)
    {
        TextureID id;
        id = TexMan.CheckForTexture(tex, TexMan.Type_MiscPatch);
        return id.isValid();
    }
	
	ui void SetFallbackTexture(String tex)
	{
		fallbackTex = tex;
	}

	// персонаж-зависимое имя клипа
	ui String FallbackAnimName()
	{
		return (character.Length()>0) ? (character .. ".FALLBACK") : "FALLBACK";
	}

	ui bool EnsureFallbackAnim()
	{
		String fbName = FallbackAnimName();
		int i = FindAnim(fbName);

		if (fallbackTex.Length() == 0)
			return (i >= 0 && clipCount[i] > 0); // есть готовый непустой — ок, иначе нечего

		int fi = EnsureFrameIndexByName(fallbackTex);
		if (fi < 0)
		{
			Console.Printf("[FALLBACK] missing texture: '%s'", fallbackTex);
			return (i >= 0 && clipCount[i] > 0);
		}

		// собираем данные однокадрового клипа
		int off = flatFrames.Size();
		flatFrames.Push(fi);
		flatDurMs.Push(3600000.0); // «вечный» кадр

		if (i >= 0)
		{
			// клип уже есть по имени — ПЕРЕОПРЕДЕЛИМ его, даже если clipCount == 0
			clipOffset[i]   = off;
			clipCount[i]    = 1;
			clipLoop[i]     = true;
			clipStopLast[i] = true;
		}
		else
		{
			// создаём новый
			animNames.Push(fbName);
			clipOffset.Push(off);
			clipCount.Push(1);
			clipLoop.Push(true);
			clipStopLast.Push(true);
		}

		Console.Printf("[FALLBACK] ready '%s' -> frame #%d (%s)", fbName, fi, TexMan.GetName(frames[fi]));
		return true;
	}



    // однокадровый клип с «панелью» из Backdrop
// 	ui bool EnsureFallbackAnim()
// 	{
// 		String fbName = FallbackAnimName();
// 		Console.Printf("looking for fallback, %s", fbName);

// 		if (FindAnim(fbName) >= 0) return true;

// 		if (fallbackTex.Length() == 0)
// 		{
// 			Console.Printf("[FALLBACK] no texture set");
// 			return false;
// 		}

// 		// пробуем как есть
// 		int fi = EnsureFrameIndexByName(fallbackTex);
// 		if (fi < 0)
// 		{
// 			Console.Printf("[FALLBACK] missing texture: '%s'", fallbackTex);
// 			return false;
// 		}

// 		Array<int> f; f.Push(fi);
// 		Array<double> d; d.Push(360); // практически «вечный» кадр
// 		DefineAnimation(fbName, f, d, true, true);

// 		Console.Printf("[FALLBACK] registered '%s' -> frame #%d (%s)", fbName, fi, TexMan.GetName(frames[fi]));
// 		return true;
// 	}

	ui void OnConversationEnd()
	{
		// Сначала инвалидируем FALLBACK'и (использует loadedChars)
		InvalidateFallbackClips();

		// Теперь можно очистить списки
		loadedChars.Clear();

		// Сброс персонажа и текущего состояния
		character = "";
		prevCharacter = "";

		// (опционально) если хочешь убить и IDLE/анимации — добавь здесь общий Reset(),
		// но обычно это лишнее: зарегистрированные клипы можно кэшировать на весь сеанс
	}


	ui bool PlayFallback()
	{
		bool okEnsure = EnsureFallbackAnim();
		if (!okEnsure) { Console.Printf("[FALLBACK] ensure failed"); return false; }

		String fbName = FallbackAnimName();
		bool ok = PlayAnim(fbName);
		Console.Printf("[FALLBACK] play %s -> %s", fbName, ok ? "OK" : "FAIL");
		return ok;
	}


	ui bool PlayForVoice(String voiceName)
	{
		EnsureCharacterForVoice(voiceName);

		// 1) основная анимация (персонажная)
		if (character.Length() > 0)
		{
			String clip = GetAnimationName(voiceName).MakeUpper(); // "JM001"
			if (PlayAnimChar(clip)) return true;
			if (PlayAnimChar("IDLE")) return true;
		}

		// 2) общий idle
		if (PlayAnim("IDLE")) return true;

		// 3) fallback (персонифицированный или общий)
		return PlayFallback();
	}

	ui bool CanDraw()
	{
		// идёт активный клип
		if (active && curClip >= 0 && clipCount[curClip] > 0) return true;

		// есть «замороженный» последний кадр (stopLast)
		if (lastFrameIdx >= 0) return true;

		// idle персонажа / общий idle
		if (character.Length()>0 && FindAnim(character .. ".IDLE") >= 0) return true;
		if (FindAnim("IDLE") >= 0) return true;

		// fallback (персон./общий)
		int i = FindAnim(FallbackAnimName());
		return (i >= 0 && clipCount[i] > 0);
	}


// 	ui bool CanDraw()
// 	{
// 		if (active && curClip >= 0 && clipCount[curClip] > 0) return true;
// 		if (character.Length()>0 && FindAnim(character .. ".IDLE") >= 0) return true;
// 		int i = FindAnim(FallbackAnimName());

// 		if (FindAnim("IDLE") >= 0) return true;

// 		return (i >= 0 && clipCount[i] > 0);
// 	}
	
	static int IndexOfStr(Array<String> arr, String s)
	{
		for (int i=0;i<arr.Size();i++) if (arr[i] == s) return i;
		return -1;
	}

	ui void Reset()
	{
		active = false;
		curClip = -1;
		seqPos = 0;
		timeLeftMs = 0;
		lastFrameIdx = -1;
	}

	int EnsureFrameIndexByName(String name)
	{
		String want = name;
		String wantLC = want.MakeLower();

		// 1) поиск среди уже загруженных без учета регистра
		for (int i = 0; i < frames.Size(); i++)
		{
			String have = TexMan.GetName(frames[i]);
			if (have.MakeLower() == wantLC) return i;
		}

		// 2) пробуем как есть
		TextureID id = TexMan.CheckForTexture(want, TexMan.Type_MiscPatch);

		// 3) пробуем в нижнем регистре (частый случай в PK3)
		if (!id.IsValid() && want != wantLC)
			id = TexMan.CheckForTexture(wantLC, TexMan.Type_MiscPatch);

		if (!id.IsValid()) return -1;

		frames.Push(id);
		return frames.Size() - 1;
	}

// 	int EnsureFrameIndexByName(String name) {
// 		for (int i = 0; i < frames.Size(); i++) {
// 		if (TexMan.GetName(frames[i]) == name) return i; }
// 		TextureID id = TexMan.CheckForTexture(name);
// 		if (!id.IsValid()) return -1;
// 		frames.Push(id);
// 		return frames.Size() - 1;
// 	}
	

// 	ui void EnsureCharacterForVoice(String voiceName)
// 	{
// 		String clearVoiceName = (voiceName.RightIndexOf("/") >= 0)
// 			? voiceName.Mid(voiceName.RightIndexOf("/") + 1)
// 			: voiceName;

// 		String who = AnimRegistryLang.ResolveCharFromVoice(clearVoiceName);

// 		if (who.Length() == 0)
// 		{
// 			character = "";     // нет персонажа — выходим
// 			// fallbackTex НЕ трогаем — его уже поставило меню под текущий узел
// 			return;
// 		}

// 		bool changed = (character != who);
// 		character = who;

// 		if (changed)
// 		{
// 			// инвалидируем старые fallback-клипы, но НЕ трогаем fallbackTex:
// 			InvalidateFallbackClips();
// 		}

// 		if (IndexOfStr(loadedChars, who) < 0)
// 		{
// 			AnimRegistryLang.PreloadFor(self, who);
// 			AnimRegistryLang.RegisterFor(self, who, true);
// 			loadedChars.Push(who);
// 		}
// 	}

	ui void EnsureCharacterForVoice(String voiceName)
	{
		String clear = (voiceName.RightIndexOf("/") >= 0) ? voiceName.Mid(voiceName.RightIndexOf("/") + 1) : voiceName;
		String who = AnimRegistryLang.ResolveCharFromVoice(clear);

		if (who.Length() == 0)
		{
			character = "";   // нет персонажа — пойдём в общий FALLBACK по текущему fallbackTex
			return;
		}

		bool changed = (character != who);
		character = who;

		if (changed)
			InvalidateFallbackClips();   // клипы обнулим, НО fallbackTex не трогаем

		if (IndexOfStr(loadedChars, who) < 0)
		{
			AnimRegistryLang.PreloadFor(self, who);
			AnimRegistryLang.RegisterFor(self, who, true);
			loadedChars.Push(who);
		}
	}


	ui void InvalidateFallbackClips()
	{
		// общий
		int k = FindAnim("FALLBACK"); if (k >= 0) clipCount[k] = 0;

		// для любого из уже загруженных персонажей
		for (int i = 0; i < loadedChars.Size(); i++)
		{
			String fb = loadedChars[i] .. ".FALLBACK";
			int j = FindAnim(fb); if (j >= 0) clipCount[j] = 0;
		}

		// если сейчас мы отображаем старый fallback — погасим проигрывание
		if (curClip >= 0)
		{
			String cur = animNames[curClip];
			if (StringEndsWith(cur, ".FALLBACK") || cur == "FALLBACK")
			{
				active = false; curClip = -1;
			}
		}
	}

	static bool StringEndsWith(String s, String suffix)
	{
		int sl = s.Length();
		int tl = suffix.Length();
		if (tl == 0) return true;
		if (sl < tl) return false;
		// хвост строки длиной suffix
		return s.Mid(sl - tl) == suffix;
	}


    bool HasAnim(String n) { return FindAnim(n) >= 0; }

    ui void PreloadOnce()
    {
        if (ready) return;

        curClip = -1; seqPos = 0; timeLeftMs = 0.0;
        active = false; lastFrameIdx = 0;
        vW = 320; vH = 200; topMargin = 0.0;
        ready = true;
    }

    // --- вспомогательные маппинги ---
	

  // --- регистрация клипов без конвертации в тики ---
	void DefineAnimation(String name, Array<int> fIdx, Array<double> durMs, bool loop=false, bool stopLast=true)
	{
		int n = min(fIdx.Size(), durMs.Size());
		if (n <= 0) return;

		int off = flatFrames.Size();
		for (int i = 0; i < n; i++)
		{
			int fi = fIdx[i]; if (fi < 0 || fi >= frames.Size()) continue;
			flatFrames.Push(fi);
			double ms = durMs[i]; if (ms <= 0) ms = 0.001; // крошечный минимум
			flatDurMs.Push(ms);
		}
		int cnt = flatFrames.Size() - off;
		if (cnt <= 0) return;

		int idx = FindAnim(name);
		if (idx >= 0) {
			clipOffset[idx] = off; clipCount[idx] = cnt;
			clipLoop[idx] = loop;  clipStopLast[idx] = stopLast;
		} else {
			animNames.Push(name);
			clipOffset.Push(off); clipCount.Push(cnt);
			clipLoop.Push(loop);  clipStopLast.Push(stopLast);
		}
	}

    void DefineAnimationByNames(String name, Array<String> fNames, Array<double> durMs, bool loop=false, bool stopLast=true)
    {

        Array<int> idx;
        int n = min(fNames.Size(), durMs.Size());
        for (int i = 0; i < n; i++)
        {
            int fi = EnsureFrameIndexByName(fNames[i]);
            if (fi >= 0) idx.Push(fi);
        }
        if (idx.Size() == 0) return;
		

        DefineAnimation(name, idx, durMs, loop, stopLast);
    }

	static String GetAnimationName(String path, String separator = "/")
	{
		int pos = path.RightIndexOf(separator);
		return (pos >= 0) ? path.Mid(pos + 1) : path;
	}


    ui bool PlayAnim(String name)
    {
        PreloadOnce();
        int idx = FindAnim(GetAnimationName(name));
	
		if (idx < 0) { Console.Printf("Anim not found: %s", name); return false; }
		if (clipCount[idx] <= 0) { Console.Printf("Anim empty: %s", name); return false; }

        if (idx < 0 || clipCount[idx] <= 0) return false;

        curClip = idx; active = true; seqPos = 0;

        int base = clipOffset[idx];
        timeLeftMs = flatDurMs[base];          // ← миллисекунды
        if (timeLeftMs <= 0) timeLeftMs = 1;

        lastFrameIdx = flatFrames[base];
        return true;
    }

	ui bool PlayAnimChar(String name)
    {
		String realName = GetAnimationName(name);
		String full;
        PreloadOnce(); 
		
        if (character.Length()>0)
        {
            full = character .. "." .. realName;
            if (FindAnim(full) >= 0) return PlayAnim(full);
        }
        return PlayAnim(realName);
    }


	ui bool TryStartIdle()
	{
		if (character.Length()>0 && FindAnim(character .. ".IDLE") >= 0)
			return PlayAnimChar("IDLE");
		if (FindAnim("IDLE") >= 0)
			return PlayAnim("IDLE");
		return false;
	}


	ui void Tick()
	{
		if (!active || curClip < 0) return;
		int cnt = clipCount[curClip];
		if (cnt <= 0) { active = false; return; }

		double dt = 1000.0 / TICRATE;
		timeLeftMs -= dt;

		while (timeLeftMs <= 0.0)
		{
			seqPos++;
			if (seqPos >= cnt)
			{
				if (clipLoop[curClip])
				{
					seqPos = 0;
				}
				else
				{
					// --- клип завершён ---
					String curName = animNames[curClip];
					bool wasIdle = (curName == "IDLE") ||
								   (character.Length()>0 && curName == character .. ".IDLE");
					bool wasFallback = (curName == "FALLBACK") ||
									   StringEndsWith(curName, ".FALLBACK");

					active = false;

					if (clipStopLast[curClip])
					{
						int last = clipOffset[curClip] + (cnt - 1);
						lastFrameIdx = flatFrames[last];
					}
					else lastFrameIdx = -1;

					// Авто-переход в idle только если это не idle и не fallback
					if (!wasIdle && !wasFallback)
					{
						if (TryStartIdle()) return;  // запустили idle — выходим
					}
					return; // ничего лучше — остаёмся на последнем кадре/скрываемся
				}
			}

			int base = clipOffset[curClip] + seqPos;
			timeLeftMs += flatDurMs[base];
			lastFrameIdx = flatFrames[base];
		}
	}

    ui void Draw()
    {
        int drawIdx = lastFrameIdx;
        if (active && curClip >= 0)
        {
            int cnt = clipCount[curClip];
            if (cnt > 0 && seqPos >= 0 && seqPos < cnt)
            {
                int base = clipOffset[curClip] + seqPos;
                drawIdx = flatFrames[base];
            }
        }
        if (drawIdx < 0 || drawIdx >= frames.Size()) return;

        TextureID tex = frames[drawIdx]; if (!tex.IsValid()) return;
        Vector2 sz = TexMan.GetScaledSize(tex);
        double x = (vW - sz.x) * 0.5;
        double y = topMargin;

        Screen.DrawTexture(tex, false, x, y,
            DTA_VirtualWidth, vW,
            DTA_VirtualHeight, vH,
            DTA_KeepRatio, true
        );
    }

    int FindAnim(String n)
    {
        for (int i = 0; i < animNames.Size(); i++) if (animNames[i] == n) return i;
        return -1;
    }

		bool IsStopped()
	{
		return !active || curClip < 0 || clipCount[curClip] <= 0;
	}

	bool IsPlaying(String name)
	{
		int idx = FindAnim(name);
		return active && idx == curClip;
	}

	int CurrentFrameIndex()
	{
		if (active && curClip >= 0)
		{
			int count = clipCount[curClip];
			if (count > 0 && seqPos >= 0 && seqPos < count)
			{
				int base = clipOffset[curClip] + seqPos;
				return flatFrames[base];
			}
		}
		return lastFrameIdx;
	}

	String CurrentAnimationName()
	{
		return (curClip >= 0 && curClip < animNames.Size()) ? animNames[curClip] : "";
	}
	
}

	
//     ui void EnsureCharacterForVoice(String voiceName)
//     {

// 		String clearVoiceName = (voiceName.RightIndexOf("/") >= 0) ? voiceName.Mid(voiceName.RightIndexOf("/") + 1) : voiceName;
//         String who = AnimRegistryLang.ResolveCharFromVoice(clearVoiceName);
// 		Console.printf("character: %s", who);
//         if (who.Length()==0) return;

//         // Регистрируем анимации этого персонажа один раз
//         if (IndexOfStr(loadedChars, who) < 0)
//         {
//             AnimRegistryLang.PreloadFor(self, who);
//             AnimRegistryLang.RegisterFor(self, who, true);
//             loadedChars.Push(who);
//         }
//         character = who; // активный персонаж
//     }


//     ui bool PlayForVoice(String voiceName)
//     {
//         EnsureCharacterForVoice(voiceName);

//         String clip = GetAnimationName(voiceName).MakeUpper();
//         if (character.Length() > 0)
//         {
//             if (PlayAnimChar(clip)) return true;
//         }
//         // персонаж не распознан или клипа нет — показываем «панель»
//         return PlayFallback();
//     }

//     ui bool PlayForVoice(String voiceName)
//     {
//         EnsureCharacterForVoice(voiceName);

//         String clip = GetAnimationName(voiceName).MakeUpper(); // "JM001"
//         if (character.Length() > 0 && PlayAnimChar(clip)) return true;

//         // попытки IDLE
//         if (character.Length() > 0 && PlayAnimChar("IDLE")) return true;
//         if (PlayAnim("IDLE")) return true;

//         // последний шанс — FALLBACK
//         if (PlayFallback()) return true;

//         return false;
//     }

//     ui bool PlayForVoice(String voice)
//     {
//         String clear, who, clip;
//         int slash;

//         slash = voice.RightIndexOf("/");
//         if (slash >= 0) clear = voice.Mid(slash + 1); else clear = voice;

//         who = AnimRegistryLang.ResolveCharFromVoice(clear);
//         if (who.Length() == 0) return false;

//         EnsureCharacterForVoice(voice); // твоя реализация как была

//         // 1) Пытаемся проиграть анимацию под имя файла (без пути)
//         clip = clear;
//         if (PlayAnimChar(clip)) return true;

//         // 2) Пытаемся IDLE
//         if (PlayAnimChar("IDLE")) return true;

//         // 3) Пытаемся одно-кадровый фолбэк из бэкдропа

//         if (PlayFallback()) return true;

//         if (fallbackStill.Length() > 0 && HasValidTexture(fallbackStill))
//         {
//             return PlayOneFrameStill(fallbackStill, 60); // реализовано у тебя/добавь: положить 1 Name и 1 длительность
//         }

//         return false;
//     }


// 	ui bool CanDraw()
// 	{
// 		if (active && curClip >= 0 && clipCount[curClip] > 0) return true;
// 		if (character.Length() > 0 && FindAnim(character .. ".IDLE") >= 0) return true;
// 		if (FindAnim("IDLE") >= 0) return true;
// 		// FALLBACK только если реально задана текстура и клип определён
// 		if (fallbackTex.Length() > 0 && FindAnim("FALLBACK") >= 0) return true;
// 		return false;
// 	}


// 	ui bool PlayForVoice(String voiceName)
// 	{
// 		EnsureCharacterForVoice(voiceName);      // выставит character = "JM"
// 		String clip = getAnimationName(voiceName); // "jm/jm001" -> "jm001"
// 		clip = clip.MakeUpper();                   // "JM001" (как в LIST)
// 		return PlayAnimChar(clip);                 // соберёт "JM.JM001"
// 	}

	
