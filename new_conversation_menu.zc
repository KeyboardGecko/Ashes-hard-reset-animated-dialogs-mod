class MyConversationMenu : ConversationMenu
{
    StrifeDialogueNode _prev;
	DialogUIOverlay o;
	String curAnim;
	
 	override int Init(StrifeDialogueNode CurNode, PlayerInfo player, int activereply)
	{
        int r = Super.Init(CurNode, player, activereply);

		o = DialogUIOverlay.Get();
 		if (!o) return r;

		o.EnsureStatic();
		o.BeginConversationStatic();
		o.HeartbeatStatic();

		// прокинуть fallback кадр для ПЕРВОГО узла
		o.SetFallbackBackdropStatic(CurNode ? CurNode.Backdrop : "");

		o.ShowVoiceStatic(CurNode.SpeakerVoice); // покажет voice/idle/fallback или спрячется (через Overlay)
		PlayNodeVoice(CurNode);

		_prev = CurNode;
		return r;
	}

	override void Ticker()
	{
		String voice;

		Super.Ticker();
		o.HeartbeatStatic();

		if (mCurNode != _prev)
		{
			// каждый раз обновляем fallback
			o.SetFallbackBackdropStatic(mCurNode ? mCurNode.Backdrop : "");

			if (mCurNode != null) voice = mCurNode.SpeakerVoice;
			else voice = "";			
			o.ShowVoiceStatic(voice);

			PlayNodeVoice(mCurNode);
			_prev = mCurNode;
		}

		if (mCurNode == null)
		{
			o.EndConversationStatic(60);
		}
	}

	
    override void Drawer()
    {

        Super.Drawer();
    }

    override bool DrawBackdrop()
    {
        return true;
    }


    // animation file should have the name of audiofile here. For consistency.
    ui String ResolveAnimForNode(StrifeDialogueNode n)
    {
        if (n == null) return "idle";

        if (n.SpeakerVoice != 0)
        {
            return getAnimationName(n.SpeakerVoice);
        }
        return "idle";
    }
	
	String getAnimationName(String path){
		int slashPos = path.RightIndexOf("/");
		String justName;
		if (slashPos >= 0)
		{
			justName = path.Mid(slashPos + 1);
		}
		else
		{
			justName = path;
		}
		return justName;
	}
	
    ui void PlayNodeVoice(StrifeDialogueNode n)
    {
        if (n == null) return;

        let cvOn  = CVar.GetCVar('jm_voice_enable', players[consoleplayer]);
        if (cvOn && !cvOn.GetBool()) return;

        double vol = 1.0;
        let cvVol = CVar.GetCVar('jm_voice_volume', players[consoleplayer]);
        if (cvVol) vol = clamp(cvVol.GetFloat(), 0.0, 1.0);

        if (n.SpeakerVoice == "" || n.SpeakerVoice == "none") return;
		
		let pl = players[consoleplayer];
		if (pl && pl.mo)
		{
		    let npc = (pl ? pl.ConversationNPC : null);   // текущий NPC, с которым идёт диалог
			if (!npc) return;
			
		// let's play in two channels. Maybe it's louder that way.
			npc.A_StartSound(n.SpeakerVoice, CHAN_6, 0, vol, ATTN_NORM);
			npc.A_StartSound(n.SpeakerVoice, CHAN_5, 0, vol, ATTN_NORM);

		}
    }
		
}

/////////////////////////////////////////////////////////////////////////
// ---- SILENCING THE ORIGINAL STRIFE DIALOG AUDIO PLAYING METHOD ----
// ---- (which sucked)----
/////////////////////////////////////////////////////////////////////////
class VoiceHijack : StaticEventHandler
{
    override void WorldTick()
    {
        // works only in game with real players
        let pi = players[consoleplayer];
        if (!pi) return;

        // choose npc which has a conversation going
        let npc = pi.ConversationNPC;
        if (!npc) return;

        // clears CHAN_VOICE, silencing that stupid p_conversation.cpp method
        npc.A_StopSound(CHAN_VOICE);
  
  }
}
