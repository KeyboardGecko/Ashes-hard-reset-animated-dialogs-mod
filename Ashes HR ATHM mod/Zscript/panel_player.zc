class PanelPlayer : Object
{
    bool ready;
    Array<TextureID> frames;

    Array<String> animNames;
    Array<int>    clipOffset, clipCount;
    Array<bool>   clipLoop, clipStopLast;
    Array<int>    flatFrames;
    Array<double>    flatDurMs;

    int  curClip, seqPos;
    bool active;
    int  lastFrameIdx;

    int vW, vH;
    double topMargin;

    double timeLeftMs;  

	String snd;

	String character;
	String prevCharacter;
	
	Array<String> loadedChars; 

    String fallbackTex;  

	// for random delay at the start of every idle animation
	static bool IsIdleName(String n) {
		return n == "IDLE" || StringEndsWith(n, ".IDLE");
	}

	bool IsCurrentClipIdle() {
		if (curClip < 0 || curClip >= animNames.Size()) return false;
		
		return IsIdleName(animNames[curClip]);
	}

	double RandomIdleHoldMs() {
		return FRandom(100, 600);
	}

    ui bool HasAnimInStringTable(String who, String anim)
    {
        String key, s;
        key = "ANIMS_"..who.."_"..anim.."_FRAMES";
        s = Stringtable.Localize(key);
        return s != key;
    }

    ui bool HasValidTexture(String tex)
    {
        TextureID id;
        id = TexMan.CheckForTexture(tex, TexMan.Type_MiscPatch);
        return id.isValid();
    }
	
	ui void SetFallbackTexture(String tex)
	{
		fallbackTex = tex;
	}

	ui String FallbackAnimName()
	{
		return (character.Length()>0) ? (character .. ".FALLBACK") : "FALLBACK";
	}

	ui bool EnsureFallbackAnim()
	{
		String fbName = FallbackAnimName();
		int i = FindAnim(fbName);

		if (fallbackTex.Length() == 0)
			return (i >= 0 && clipCount[i] > 0); 

		int fi = EnsureFrameIndexByName(fallbackTex);
		if (fi < 0)
		{
			return (i >= 0 && clipCount[i] > 0);
		}

		int off = flatFrames.Size();
		flatFrames.Push(fi);
		flatDurMs.Push(3600000.0); 

		if (i >= 0)
		{
			clipOffset[i]   = off;
			clipCount[i]    = 1;
			clipLoop[i]     = true;
			clipStopLast[i] = true;
		}
		else
		{
			animNames.Push(fbName);
			clipOffset.Push(off);
			clipCount.Push(1);
			clipLoop.Push(true);
			clipStopLast.Push(true);
		}

		return true;
	}

	ui void OnConversationEnd()
	{
		InvalidateFallbackClips();
		loadedChars.Clear();

		character = "";
		prevCharacter = "";

	}


	ui bool PlayFallback()
	{
		bool okEnsure = EnsureFallbackAnim();
		if (!okEnsure)  return false; 

		String fbName = FallbackAnimName();
		bool ok = PlayAnim(fbName);
		return ok;
	}


	ui bool PlayForVoice(String voiceName)
	{
		EnsureCharacterForVoice(voiceName);

		if (character.Length() > 0)
		{
			String clip = GetAnimationName(voiceName).MakeUpper(); // "JM001"
			if (PlayAnimChar(clip)) return true;
			if (PlayAnimChar("IDLE")) return true;
		}

		if (PlayAnim("IDLE")) return true;

		return PlayFallback();
	}

	ui bool CanDraw()
	{
		if (active && curClip >= 0 && clipCount[curClip] > 0) return true;

		if (lastFrameIdx >= 0) return true;

		if (character.Length()>0 && FindAnim(character .. ".IDLE") >= 0) return true;
		if (FindAnim("IDLE") >= 0) return true;

		int i = FindAnim(FallbackAnimName());
		return (i >= 0 && clipCount[i] > 0);
	}

	
	static int IndexOfStr(Array<String> arr, String s)
	{
		for (int i=0;i<arr.Size();i++) if (arr[i] == s) return i;
		return -1;
	}

	ui void Reset()
	{
		active = false;
		curClip = -1;
		seqPos = 0;
		timeLeftMs = 0;
		lastFrameIdx = -1;
	}

	int EnsureFrameIndexByName(String name)
	{
		String want = name;
		String wantLC = want.MakeLower();

		for (int i = 0; i < frames.Size(); i++)
		{
			String have = TexMan.GetName(frames[i]);
			if (have.MakeLower() == wantLC) return i;
		}

		TextureID id = TexMan.CheckForTexture(want, TexMan.Type_MiscPatch);

		if (!id.IsValid() && want != wantLC)
			id = TexMan.CheckForTexture(wantLC, TexMan.Type_MiscPatch);

		if (!id.IsValid()) return -1;

		frames.Push(id);
		return frames.Size() - 1;
	}


	ui void EnsureCharacterForVoice(String voiceName)
	{
		String clear = (voiceName.RightIndexOf("/") >= 0) ? voiceName.Mid(voiceName.RightIndexOf("/") + 1) : voiceName;
		String who = AnimRegistryLang.ResolveCharFromVoice(clear);

		if (who.Length() == 0)
		{
			return;
		}

		bool changed = (character != who);
		character = who;

		if (changed)
			InvalidateFallbackClips(); 

		if (IndexOfStr(loadedChars, who) < 0)
		{
			AnimRegistryLang.PreloadFor(self, who);
			AnimRegistryLang.RegisterFor(self, who, true);
			loadedChars.Push(who);
		}
	}


	ui void InvalidateFallbackClips()
	{
		int k = FindAnim("FALLBACK"); if (k >= 0) clipCount[k] = 0;

		for (int i = 0; i < loadedChars.Size(); i++)
		{
			String fb = loadedChars[i] .. ".FALLBACK";
			int j = FindAnim(fb); if (j >= 0) clipCount[j] = 0;
		}

		// if old fallback is displayed
		if (curClip >= 0)
		{
			String cur = animNames[curClip];
			if (StringEndsWith(cur, ".FALLBACK") || cur == "FALLBACK")
			{
				active = false; curClip = -1;
			}
		}
	}

	static bool StringEndsWith(String s, String suffix)
	{
		int sl = s.Length();
		int tl = suffix.Length();
		if (tl == 0) return true;
		if (sl < tl) return false;
		// хвост строки длиной suffix
		return s.Mid(sl - tl) == suffix;
	}


    bool HasAnim(String n) { return FindAnim(n) >= 0; }

    ui void PreloadOnce()
    {
        if (ready) return;

        curClip = -1; seqPos = 0; timeLeftMs = 0.0;
        active = false; lastFrameIdx = 0;
        vW = 320; vH = 200; topMargin = 0.0;
        ready = true;
    }

    // --- helpers ---
	
	void DefineAnimation(String name, Array<int> fIdx, Array<double> durMs, bool loop=false, bool stopLast=true)
	{
		int n = min(fIdx.Size(), durMs.Size());
		if (n <= 0) return;

		int off = flatFrames.Size();
		for (int i = 0; i < n; i++)
		{
			int fi = fIdx[i]; if (fi < 0 || fi >= frames.Size()) continue;
			flatFrames.Push(fi);
			double ms = durMs[i]; if (ms <= 0) ms = 0.001; // крошечный минимум
			flatDurMs.Push(ms);
		}
		int cnt = flatFrames.Size() - off;
		if (cnt <= 0) return;

		int idx = FindAnim(name);
		if (idx >= 0) {
			clipOffset[idx] = off; clipCount[idx] = cnt;
			clipLoop[idx] = loop;  clipStopLast[idx] = stopLast;
		} else {
			animNames.Push(name);
			clipOffset.Push(off); clipCount.Push(cnt);
			clipLoop.Push(loop);  clipStopLast.Push(stopLast);
		}
	}

    void DefineAnimationByNames(String name, Array<String> fNames, Array<double> durMs, bool loop=false, bool stopLast=true)
    {

        Array<int> idx;
        int n = min(fNames.Size(), durMs.Size());
        for (int i = 0; i < n; i++)
        {
            int fi = EnsureFrameIndexByName(fNames[i]);
            if (fi >= 0) idx.Push(fi);
        }
        if (idx.Size() == 0) return;
		

        DefineAnimation(name, idx, durMs, loop, stopLast);
    }

	static String GetAnimationName(String path, String separator = "/")
	{
		int pos = path.RightIndexOf(separator);
		return (pos >= 0) ? path.Mid(pos + 1) : path;
	}


    ui bool PlayAnim(String name)
    {
        PreloadOnce();
        int idx = FindAnim(GetAnimationName(name));
	
		if (idx < 0) return false; 
		if (clipCount[idx] <= 0)  return false; 

        if (idx < 0 || clipCount[idx] <= 0) return false;

        curClip = idx; active = true; seqPos = 0;

        int base = clipOffset[idx];
        timeLeftMs = flatDurMs[base];          // ← миллисекунды
        if (timeLeftMs <= 0) timeLeftMs = 1;

	    if (IsIdleName(GetAnimationName(name))) {
			timeLeftMs += RandomIdleHoldMs();
		}


        lastFrameIdx = flatFrames[base];
        return true;
    }

	ui bool PlayAnimChar(String name)
    {
		String realName = GetAnimationName(name);
		String full;
        PreloadOnce(); 
		
        if (character.Length()>0)
        {
            full = character .. "." .. realName;
            if (FindAnim(full) >= 0) return PlayAnim(full);
        }
        return PlayAnim(realName);
    }


	ui bool TryStartIdle()
	{
		if (character.Length()>0 && FindAnim(character .. ".IDLE") >= 0)
			return PlayAnimChar("IDLE");
		if (FindAnim("IDLE") >= 0)
			return PlayAnim("IDLE");
		return false;
	}


	ui void Tick()
	{
		if (!active || curClip < 0) return;
		int cnt = clipCount[curClip];
		if (cnt <= 0) { active = false; return; }

		double dt = 1000.0 / TICRATE;
		timeLeftMs -= dt;

		while (timeLeftMs <= 0.0)
		{
			seqPos++;
			if (seqPos >= cnt)
			{
				if (clipLoop[curClip])
				{
					seqPos = 0;
				}
				else
				{
					String curName = animNames[curClip];
					bool wasIdle = (curName == "IDLE") ||
								   (character.Length()>0 && curName == character .. ".IDLE");
					bool wasFallback = (curName == "FALLBACK") ||
									   StringEndsWith(curName, ".FALLBACK");

					active = false;

					if (clipStopLast[curClip])
					{
						int last = clipOffset[curClip] + (cnt - 1);
						lastFrameIdx = flatFrames[last];
					}
					else lastFrameIdx = -1;

					if (!wasIdle && !wasFallback)
					{
						if (TryStartIdle()) return;
					}
					return;
				}
			}

			int base = clipOffset[curClip] + seqPos;
			timeLeftMs += flatDurMs[base];
			lastFrameIdx = flatFrames[base];
		}
	}

    ui void Draw()
    {
        int drawIdx = lastFrameIdx;
        if (active && curClip >= 0)
        {
            int cnt = clipCount[curClip];
            if (cnt > 0 && seqPos >= 0 && seqPos < cnt)
            {
                int base = clipOffset[curClip] + seqPos;
                drawIdx = flatFrames[base];
            }
        }
        if (drawIdx < 0 || drawIdx >= frames.Size()) return;

        TextureID tex = frames[drawIdx]; if (!tex.IsValid()) return;
        Vector2 sz = TexMan.GetScaledSize(tex);
        double x = (vW - sz.x) * 0.5;
        double y = (vH - sz.y) * 0.25;
//         double y = topMargin;

        Screen.DrawTexture(tex, false, x, y,
            DTA_VirtualWidth, vW,
            DTA_VirtualHeight, vH,
            DTA_KeepRatio, true,
			DTA_TopLeft,       true
        );
    }

    int FindAnim(String n)
    {
        for (int i = 0; i < animNames.Size(); i++) if (animNames[i] == n) return i;
        return -1;
    }

		bool IsStopped()
	{
		return !active || curClip < 0 || clipCount[curClip] <= 0;
	}

	bool IsPlaying(String name)
	{
		int idx = FindAnim(name);
		return active && idx == curClip;
	}

	int CurrentFrameIndex()
	{
		if (active && curClip >= 0)
		{
			int count = clipCount[curClip];
			if (count > 0 && seqPos >= 0 && seqPos < count)
			{
				int base = clipOffset[curClip] + seqPos;
				return flatFrames[base];
			}
		}
		return lastFrameIdx;
	}

	String CurrentAnimationName()
	{
		return (curClip >= 0 && curClip < animNames.Size()) ? animNames[curClip] : "";
	}
	
}